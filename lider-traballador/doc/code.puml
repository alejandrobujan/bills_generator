@startuml duxir_code

class Core.ServiceHandler {
  +service: atom
  +client_queue: queue<GenServer.from>
  +min_workers: pos_integer
  +next_worker_id: pos_integer

  +new(service: atom, module: atom, min_workers: pos_integer) :: ServiceHandler
  +spawn_worker(handler: ServiceHandler) :: ServiceHandler
  +spawn_workers(handler: ServiceHandler, n: pos_integer) :: ServiceHandler
  +kill_worker(handler: ServiceHandler) :: ServiceHandler
  +kill_workers(handler: ServiceHandler, n: pos_integer) :: ServiceHandler
  +all_workers_busy?(handler: ServiceHandler) :: boolean  
  +any_pending_client?(handler: ServiceHandler) :: boolean
  +enqueue_client(handler: ServiceHandler, cliente: GenServer.from) :: ServiceHandler
  +dequeue_client(handler: ServiceHandler) :: {GenServer.from, ServiceHandler}
  +assign_job(handler: ServiceHandler, client: GenServer.from) :: ServiceHandler
  +assign_job(handler: ServiceHandler) :: ServiceHandler
  +assign_jobs(handler: ServiceHandler, n: non_neg_integer) :: ServiceHandler
  +free_worker(handler: ServiceHandler, worker: GenServer.server()) :: {GenServer.from, ServiceHandler}
  +total_pending_clients(handler: ServiceHandler) :: non_neg_integer
  +total_free_workers(handler: ServiceHandler) :: non_neg_integer
  +total_workers(handler: ServiceHandler) :: non_neg_integer
  +stop_workers(handler: ServiceHandler) :: ServiceHandler
}

Core.StandardServer "N" <--o "1" Core.ServiceHandler: workers
Core.StandardServer "1" <--o "1" Core.ServiceHandler: module
Core.StandardServer "N" <--o "1" Core.ServiceHandler: free_workers
Core.StandardServer "N" <--o "1" Core.ServiceHandler: busy_workers : %{GenServer.server => GenServer.from}





class Core.Leader implements Elixir.GenServer{
  +start_link(Keyword<{StandardServer, pos_integer}>) :: {:ok, pid}
  +stop() :: :ok
  +get(service: atom) :: {:ok, Any} | {:error, Any}
  +get_services() :: list<atom>
  +redirect(service: atom, worker: pid, message: Any) :: :ok
  -check_services_workload(period: pos_integer) :: :ok
  -handle_workload_rate(service_handler: ServiceHandler, workload_rate: float) :: ServiceHandler
}


Core.ServiceHandler "N" <--o "1" Core.Leader: state: %{atom => ServiceHandler}

interface Elixir.GenServer
interface Elixir.Application

interface Core.StandardServer implements Elixir.GenServer{
  +start_link(service: atom, name: atom) :: {:ok, pid}
  +get(server: GenServer.server) :: :ok
  +stop(server: GenServer.server) :: :ok
  +handle_get() :: Any
}

class Services.Service1 implements Core.StandardServer{
  +handle_get() :: String
}
class Services.Service2 implements Core.StandardServer{
  +handle_get() :: String
}

class Duxir.Application implements Elixir.Application{
  +start(_type, _args) :: {:ok, pid}
}


' Core.ServiceHandler o-- Core.StandardServer
Core.Leader <-- Duxir.Application



@enduml 